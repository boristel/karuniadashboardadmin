"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/sales-monitoring/page",{

/***/ "(app-pages-browser)/./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   articlesAPI: function() { return /* binding */ articlesAPI; },\n/* harmony export */   authAPI: function() { return /* binding */ authAPI; },\n/* harmony export */   branchesAPI: function() { return /* binding */ branchesAPI; },\n/* harmony export */   categoriesAPI: function() { return /* binding */ categoriesAPI; },\n/* harmony export */   colorsAPI: function() { return /* binding */ colorsAPI; },\n/* harmony export */   createCRUDAPI: function() { return /* binding */ createCRUDAPI; },\n/* harmony export */   salesMonitoringAPI: function() { return /* binding */ salesMonitoringAPI; },\n/* harmony export */   salesProfilesAPI: function() { return /* binding */ salesProfilesAPI; },\n/* harmony export */   salesStaffAPI: function() { return /* binding */ salesStaffAPI; },\n/* harmony export */   spkAPI: function() { return /* binding */ spkAPI; },\n/* harmony export */   supervisorsAPI: function() { return /* binding */ supervisorsAPI; },\n/* harmony export */   testStrapiConnection: function() { return /* binding */ testStrapiConnection; },\n/* harmony export */   uploadFile: function() { return /* binding */ uploadFile; },\n/* harmony export */   usersAPI: function() { return /* binding */ usersAPI; },\n/* harmony export */   vehicleGroupsAPI: function() { return /* binding */ vehicleGroupsAPI; },\n/* harmony export */   vehicleTypesAPI: function() { return /* binding */ vehicleTypesAPI; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _process_env_NEXT_PUBLIC_STRAPI_URL;\n\n// Get API base URL from environment\nconst API_BASE_URL = \"http://localhost:1337/api\" || 0;\nconst STRAPI_BASE_URL = ((_process_env_NEXT_PUBLIC_STRAPI_URL = \"http://localhost:1337/api\") === null || _process_env_NEXT_PUBLIC_STRAPI_URL === void 0 ? void 0 : _process_env_NEXT_PUBLIC_STRAPI_URL.replace(\"/api\", \"\")) || \"\";\nconst API_TOKEN = process.env.STRAPI_API_TOKEN;\n// Create axios instance\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Add request interceptor to include auth token\napi.interceptors.request.use((config)=>{\n    var _config_url, _config_method;\n    // Don't add Authorization header for auth endpoints\n    const isAuthEndpoint = (_config_url = config.url) === null || _config_url === void 0 ? void 0 : _config_url.includes(\"/auth/\");\n    console.log(\"\\uD83C\\uDF10 MAIN API REQUEST: \".concat((_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase(), \" \").concat(config.baseURL).concat(config.url), {\n        isAuthEndpoint,\n        hasJwtToken: !!localStorage.getItem(\"jwt_token\"),\n        hasApiToken: !!API_TOKEN,\n        headers: config.headers,\n        data: config.data\n    });\n    if (!isAuthEndpoint) {\n        const token = localStorage.getItem(\"jwt_token\");\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n            console.log(\"\\uD83D\\uDD10 Added JWT token to request\");\n        } else if (API_TOKEN) {\n            // Use API token only if no JWT token present\n            config.headers.Authorization = \"Bearer \".concat(API_TOKEN);\n            console.log(\"\\uD83D\\uDD11 Added API token to request\");\n        }\n    } else {\n        console.log(\"\\uD83D\\uDEAB Skipping auth token for auth endpoint\");\n    }\n    return config;\n}, (error)=>{\n    console.error(\"❌ Request interceptor error:\", error);\n    return Promise.reject(error);\n});\n// Add response interceptor for error handling\napi.interceptors.response.use((response)=>response, (error)=>{\n    var _error_response;\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401) {\n        // Unauthorized - clear token and redirect to login\n        localStorage.removeItem(\"jwt_token\");\n        localStorage.removeItem(\"user\");\n        window.location.href = \"/auth/login\";\n    }\n    return Promise.reject(error);\n});\n// Test function to check Strapi endpoints\nconst testStrapiConnection = async ()=>{\n    try {\n        console.log(\"Testing Strapi connection...\");\n        // Test 1: Check if Strapi is running\n        const response1 = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(STRAPI_BASE_URL, \"/\"));\n        console.log(\"Strapi root status:\", response1.status);\n        // Test 2: Check if API endpoints exist\n        const response2 = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_BASE_URL, \"/users\"));\n        console.log(\"API users status:\", response2.status);\n        // Test 3: Try auth endpoint with different URLs\n        const possibleAuthUrls = [\n            \"\".concat(STRAPI_BASE_URL, \"/auth/local\"),\n            \"\".concat(API_BASE_URL, \"/auth/local\"),\n            \"\".concat(STRAPI_BASE_URL, \"/api/auth/local\")\n        ];\n        for (const url of possibleAuthUrls){\n            try {\n                const testResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(url, {}, {\n                    validateStatus: ()=>true // Don't throw on error status codes\n                });\n                console.log(\"Auth endpoint test for \".concat(url, \":\"), testResponse.status, testResponse.statusText);\n            } catch (e) {\n                console.log(\"Auth endpoint test for \".concat(url, \": ERROR\"), e.code);\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error(\"Strapi connection test failed:\", error.message);\n        return false;\n    }\n};\n// Auth endpoints\nconst authAPI = {\n    login: async (identifier, password)=>{\n        // Try different endpoint patterns\n        const endpoints = [\n            \"/auth/local\",\n            \"/admin/login\"\n        ];\n        console.log(\"\\uD83D\\uDD0D API_BASE_URL:\", API_BASE_URL);\n        console.log(\"\\uD83D\\uDD0D STRAPI_BASE_URL:\", STRAPI_BASE_URL);\n        for (const endpoint of endpoints){\n            // Use API_BASE_URL for auth endpoints (includes /api)\n            const loginUrl = \"\".concat(API_BASE_URL).concat(endpoint);\n            console.log(\"=== Attempting login to: \".concat(loginUrl, \" ===\"));\n            try {\n                // Use direct axios call to avoid baseURL confusion\n                const axiosInstance = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n                    baseURL: API_BASE_URL,\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                // Try different payload formats\n                const payloads = [\n                    {\n                        identifier,\n                        password\n                    },\n                    {\n                        email: identifier,\n                        password\n                    }\n                ];\n                for (const payload of payloads){\n                    try {\n                        console.log(\"--- Trying payload for \".concat(endpoint, \":\"), payload);\n                        const response = await axiosInstance.post(endpoint, payload);\n                        console.log(\"✅ SUCCESS! Login successful with \".concat(endpoint, \" using payload:\"), payload);\n                        console.log(\"✅ Response data:\", response.data);\n                        console.log(\"✅ Response headers:\", response.headers);\n                        console.log(\"✅ Response status:\", response.status);\n                        return response.data;\n                    } catch (payloadError) {\n                        var _payloadError_response, _payloadError_response1, _payloadError_response2, _payloadError_config, _payloadError_config1, _payloadError_config2, _payloadError_config3, _payloadError_response3;\n                        console.log(\"❌ Payload failed for \".concat(endpoint, \":\"), {\n                            status: (_payloadError_response = payloadError.response) === null || _payloadError_response === void 0 ? void 0 : _payloadError_response.status,\n                            statusText: (_payloadError_response1 = payloadError.response) === null || _payloadError_response1 === void 0 ? void 0 : _payloadError_response1.statusText,\n                            data: (_payloadError_response2 = payloadError.response) === null || _payloadError_response2 === void 0 ? void 0 : _payloadError_response2.data,\n                            config: {\n                                method: (_payloadError_config = payloadError.config) === null || _payloadError_config === void 0 ? void 0 : _payloadError_config.method,\n                                url: (_payloadError_config1 = payloadError.config) === null || _payloadError_config1 === void 0 ? void 0 : _payloadError_config1.url,\n                                baseURL: (_payloadError_config2 = payloadError.config) === null || _payloadError_config2 === void 0 ? void 0 : _payloadError_config2.baseURL,\n                                headers: (_payloadError_config3 = payloadError.config) === null || _payloadError_config3 === void 0 ? void 0 : _payloadError_config3.headers\n                            }\n                        });\n                        // 400 means endpoint exists but credentials are wrong - this is expected behavior\n                        if (((_payloadError_response3 = payloadError.response) === null || _payloadError_response3 === void 0 ? void 0 : _payloadError_response3.status) === 400) {\n                            console.log(\"ℹ️ INFO: 400 Bad Request for \".concat(endpoint, \" - endpoint exists but credentials are invalid\"));\n                            // If this is the first endpoint that returns 400, throw it so user sees \"Invalid credentials\"\n                            throw payloadError;\n                        }\n                        continue;\n                    }\n                }\n            } catch (endpointError) {\n                var _endpointError_response, _endpointError_response1, _endpointError_response2, _endpointError_response3, _endpointError_response4, _endpointError_response5;\n                console.log(\"=== Endpoint \".concat(endpoint, \" completely failed ===\"), {\n                    status: (_endpointError_response = endpointError.response) === null || _endpointError_response === void 0 ? void 0 : _endpointError_response.status,\n                    statusText: (_endpointError_response1 = endpointError.response) === null || _endpointError_response1 === void 0 ? void 0 : _endpointError_response1.statusText,\n                    data: (_endpointError_response2 = endpointError.response) === null || _endpointError_response2 === void 0 ? void 0 : _endpointError_response2.data,\n                    message: endpointError.message\n                });\n                // If this endpoint doesn't exist (404) or method not allowed (405), try next endpoint\n                if (((_endpointError_response3 = endpointError.response) === null || _endpointError_response3 === void 0 ? void 0 : _endpointError_response3.status) === 404 || ((_endpointError_response4 = endpointError.response) === null || _endpointError_response4 === void 0 ? void 0 : _endpointError_response4.status) === 405) {\n                    var _endpointError_response6;\n                    console.log(\"ℹ️ INFO: Endpoint \".concat(endpoint, \" not available (\").concat((_endpointError_response6 = endpointError.response) === null || _endpointError_response6 === void 0 ? void 0 : _endpointError_response6.status, \"), trying next endpoint\"));\n                    continue;\n                }\n                // If we got a 400 (invalid credentials), that means the endpoint exists but credentials are wrong\n                if (((_endpointError_response5 = endpointError.response) === null || _endpointError_response5 === void 0 ? void 0 : _endpointError_response5.status) === 400) {\n                    console.log(\"ℹ️ INFO: Endpoint \".concat(endpoint, \" exists but credentials invalid - throwing error\"));\n                    throw endpointError;\n                }\n                continue;\n            }\n        }\n        // If we get here, all endpoints failed with non-400 errors\n        console.error(\"\\uD83D\\uDEA8 ERROR: All authentication endpoints failed\");\n        throw new Error(\"No valid authentication endpoint found\");\n    },\n    register: async (username, email, password)=>{\n        const response = await api.post(\"/auth/local/register\", {\n            username,\n            email,\n            password\n        });\n        return response.data;\n    },\n    me: async ()=>{\n        const response = await api.get(\"/users/me\", {\n            params: {\n                populate: \"*\"\n            }\n        });\n        return response.data;\n    },\n    forgotPassword: async (email)=>{\n        const response = await api.post(\"/auth/forgot-password\", {\n            email\n        });\n        return response.data;\n    },\n    resetPassword: async (code, password, passwordConfirmation)=>{\n        const response = await api.post(\"/auth/reset-password\", {\n            code,\n            password,\n            passwordConfirmation\n        });\n        return response.data;\n    }\n};\n// Generic CRUD operations\nconst createCRUDAPI = (endpoint)=>({\n        getAll: async function() {\n            let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            console.log(\"\\uD83D\\uDD0D [CRUD] \".concat(endpoint, \".getAll called with params:\"), params);\n            try {\n                var _response_data_data, _response_data, _response_data1;\n                const response = await api.get(\"/\".concat(endpoint), {\n                    params\n                });\n                console.log(\"✅ [CRUD] \".concat(endpoint, \".getAll SUCCESS:\"), {\n                    status: response.status,\n                    dataCount: ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : (_response_data_data = _response_data.data) === null || _response_data_data === void 0 ? void 0 : _response_data_data.length) || 0,\n                    hasData: !!((_response_data1 = response.data) === null || _response_data1 === void 0 ? void 0 : _response_data1.data),\n                    dataKeys: response.data ? Object.keys(response.data) : \"null\"\n                });\n                return response.data; // Returns { data: [...], meta: {...} }\n            } catch (error) {\n                var _error_response, _error_response1, _error_response2;\n                console.error(\"❌ [CRUD] \".concat(endpoint, \".getAll ERROR:\"), {\n                    message: error.message,\n                    status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                    statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n                    data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data\n                });\n                throw error;\n            }\n        },\n        getById: async (id)=>{\n            console.log(\"\\uD83D\\uDD0D [CRUD] \".concat(endpoint, \".getById called with id:\"), id);\n            try {\n                var _response_data;\n                const response = await api.get(\"/\".concat(endpoint, \"/\").concat(id));\n                console.log(\"✅ [CRUD] \".concat(endpoint, \".getById SUCCESS:\"), {\n                    status: response.status,\n                    hasData: !!((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.data)\n                });\n                return response.data; // Returns { data: {...} }\n            } catch (error) {\n                var _error_response, _error_response1;\n                console.error(\"❌ [CRUD] \".concat(endpoint, \".getById ERROR:\"), {\n                    message: error.message,\n                    status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                    statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText\n                });\n                throw error;\n            }\n        },\n        create: async (data)=>{\n            console.log(\"\\uD83D\\uDD0D [CRUD] \".concat(endpoint, \".create called with data:\"), data);\n            try {\n                var _response_data;\n                const response = await api.post(\"/\".concat(endpoint), {\n                    data\n                });\n                console.log(\"✅ [CRUD] \".concat(endpoint, \".create SUCCESS:\"), {\n                    status: response.status,\n                    hasData: !!((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.data)\n                });\n                return response.data;\n            } catch (error) {\n                var _error_response, _error_response1, _error_response2;\n                console.error(\"❌ [CRUD] \".concat(endpoint, \".create ERROR:\"), {\n                    message: error.message,\n                    status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                    statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n                    data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data\n                });\n                throw error;\n            }\n        },\n        update: async (id, data)=>{\n            console.log(\"\\uD83D\\uDD0D [CRUD] \".concat(endpoint, \".update called with id:\"), id, \"data:\", data);\n            try {\n                var _response_data;\n                const response = await api.put(\"/\".concat(endpoint, \"/\").concat(id), {\n                    data\n                });\n                console.log(\"✅ [CRUD] \".concat(endpoint, \".update SUCCESS:\"), {\n                    status: response.status,\n                    hasData: !!((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.data)\n                });\n                return response.data;\n            } catch (error) {\n                var _error_response, _error_response1, _error_response2;\n                console.error(\"❌ [CRUD] \".concat(endpoint, \".update ERROR:\"), {\n                    message: error.message,\n                    status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                    statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n                    data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data\n                });\n                throw error;\n            }\n        },\n        delete: async (id)=>{\n            console.log(\"\\uD83D\\uDD0D [CRUD] \".concat(endpoint, \".delete called with id:\"), id);\n            try {\n                var _response_data;\n                const response = await api.delete(\"/\".concat(endpoint, \"/\").concat(id));\n                console.log(\"✅ [CRUD] \".concat(endpoint, \".delete SUCCESS:\"), {\n                    status: response.status,\n                    hasData: !!((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.data)\n                });\n                return response.data; // Returns { data: {...}, meta: {...} }\n            } catch (error) {\n                var _error_response, _error_response1;\n                console.error(\"❌ [CRUD] \".concat(endpoint, \".delete ERROR:\"), {\n                    message: error.message,\n                    status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                    statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText\n                });\n                throw error;\n            }\n        },\n        // Custom query for Strapi filters\n        find: async function() {\n            let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            console.log(\"\\uD83D\\uDD0D [CRUD] \".concat(endpoint, \".find called with filters:\"), filters);\n            try {\n                var _response_data_data, _response_data, _response_data1, _response_data_data1, _response_data2;\n                const response = await api.get(\"/\".concat(endpoint), {\n                    params: {\n                        populate: \"*\",\n                        ...filters\n                    }\n                });\n                console.log(\"✅ [CRUD] \".concat(endpoint, \".find SUCCESS:\"), {\n                    status: response.status,\n                    dataCount: ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : (_response_data_data = _response_data.data) === null || _response_data_data === void 0 ? void 0 : _response_data_data.length) || 0,\n                    hasData: !!((_response_data1 = response.data) === null || _response_data1 === void 0 ? void 0 : _response_data1.data),\n                    dataKeys: response.data ? Object.keys(response.data) : \"null\"\n                });\n                console.log(\"\\uD83D\\uDCCA [CRUD] \".concat(endpoint, \".find data sample:\"), (_response_data2 = response.data) === null || _response_data2 === void 0 ? void 0 : (_response_data_data1 = _response_data2.data) === null || _response_data_data1 === void 0 ? void 0 : _response_data_data1.slice(0, 1));\n                return response.data; // Returns { data: [...], meta: {...} }\n            } catch (error) {\n                var _error_response, _error_response1, _error_response2;\n                console.error(\"❌ [CRUD] \".concat(endpoint, \".find ERROR:\"), {\n                    message: error.message,\n                    status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                    statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n                    data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data\n                });\n                throw error;\n            }\n        }\n    });\n// Specific API endpoints\nconst spkAPI = createCRUDAPI(\"spks\");\nconst vehicleTypesAPI = createCRUDAPI(\"vehicle-types\");\nconst vehicleGroupsAPI = createCRUDAPI(\"vehicle-groups\");\nconst colorsAPI = createCRUDAPI(\"colors\");\nconst supervisorsAPI = createCRUDAPI(\"supervisors\");\nconst branchesAPI = createCRUDAPI(\"branches\");\nconst salesStaffAPI = createCRUDAPI(\"sales-staffs\");\n// Sales Profile API\nconst salesProfilesAPI = createCRUDAPI(\"sales-profiles\");\n// Information/Articles API\nconst articlesAPI = createCRUDAPI(\"articles\");\n// Sales Monitoring API\nconst salesMonitoringAPI = {\n    // Get all sales profiles with their SPK data and populated relationships\n    getSalesProfilesWithSPK: async ()=>{\n        // Use URL-encoded populate parameters for Strapi\n        const populateParams = [\n            \"populate[photo_profile]\",\n            \"populate[spks][populate][unitInfo][populate][vehicleType]\",\n            \"populate[spks][populate][unitInfo][populate][color]\",\n            \"populate[spks][populate][detailInfo]\",\n            \"populate[spks][populate][paymentInfo]\"\n        ];\n        const params = {\n            populate: populateParams.join(\"&\"),\n            filters: {\n                blocked: false\n            },\n            sort: \"updatedAt:desc\"\n        };\n        console.log(\"\\uD83D\\uDD0D [SalesMonitoring] API Request params:\", JSON.stringify(params, null, 2));\n        try {\n            var _response_data_data, _response_data;\n            // Build the URL manually for complex populate\n            const queryString = new URLSearchParams();\n            populateParams.forEach((param)=>queryString.append(param, \"\"));\n            queryString.append(\"filters[blocked]\", \"false\");\n            queryString.append(\"sort\", \"updatedAt:desc\");\n            const response = await api.get(\"/sales-profiles?\".concat(queryString.toString()));\n            console.log(\"✅ [SalesMonitoring] API Response status:\", response.status);\n            console.log(\"\\uD83D\\uDCCA [SalesMonitoring] Response data count:\", ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : (_response_data_data = _response_data.data) === null || _response_data_data === void 0 ? void 0 : _response_data_data.length) || 0);\n            return response.data;\n        } catch (error) {\n            var _error_response, _error_response1;\n            console.error(\"❌ [SalesMonitoring] API Error:\", (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status, (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data);\n            // Try simpler populate if complex one fails\n            try {\n                var _response_data_data1, _response_data1;\n                console.log(\"\\uD83D\\uDD04 [SalesMonitoring] Trying simpler populate...\");\n                const response = await api.get(\"/sales-profiles?populate=*\");\n                console.log(\"✅ [SalesMonitoring] Simple populate Response status:\", response.status);\n                console.log(\"\\uD83D\\uDCCA [SalesMonitoring] Response data count:\", ((_response_data1 = response.data) === null || _response_data1 === void 0 ? void 0 : (_response_data_data1 = _response_data1.data) === null || _response_data_data1 === void 0 ? void 0 : _response_data_data1.length) || 0);\n                return response.data;\n            } catch (fallbackError) {\n                var _fallbackError_response, _fallbackError_response1;\n                console.error(\"❌ [SalesMonitoring] Fallback API Error:\", (_fallbackError_response = fallbackError.response) === null || _fallbackError_response === void 0 ? void 0 : _fallbackError_response.status, (_fallbackError_response1 = fallbackError.response) === null || _fallbackError_response1 === void 0 ? void 0 : _fallbackError_response1.data);\n                throw fallbackError;\n            }\n        }\n    },\n    // Get sales profiles filtered by online status\n    getSalesProfilesByStatus: async (onlineStatus)=>{\n        const filters = {\n            approved: true,\n            blocked: false\n        };\n        if (onlineStatus !== undefined) {\n            filters.online_stat = onlineStatus;\n        }\n        const response = await api.get(\"/sales-profiles\", {\n            params: {\n                populate: \"*\",\n                filters,\n                sort: {\n                    updatedAt: \"desc\"\n                }\n            }\n        });\n        return response.data;\n    },\n    // Update sales profile location and online status\n    updateSalesProfileLocation: async (profileId, location, onlineStatus)=>{\n        const response = await api.put(\"/sales-profiles/\".concat(profileId), {\n            data: {\n                location,\n                online_stat: onlineStatus,\n                updatedAt: new Date().toISOString()\n            }\n        });\n        return response.data;\n    }\n};\n// User management API\nconst usersAPI = {\n    // Get all users with SALES role\n    getSalesUsers: async ()=>{\n        const response = await api.get(\"/users\", {\n            params: {\n                filters: {\n                    role_custom: \"SALES\"\n                },\n                populate: \"*\"\n            }\n        });\n        return response.data;\n    },\n    // Update user data\n    updateUser: async (userId, userData)=>{\n        const response = await api.put(\"/users/\".concat(userId), {\n            data: userData\n        });\n        return response.data;\n    },\n    // Get supervisors for dropdown\n    getSupervisors: async ()=>{\n        const response = await api.get(\"/supervisors\", {\n            params: {\n                populate: \"*\"\n            }\n        });\n        return response.data;\n    },\n    // Get current user info\n    getCurrentUser: async ()=>{\n        const response = await api.get(\"/users/me\", {\n            params: {\n                populate: \"*\"\n            }\n        });\n        return response.data;\n    }\n};\n// Categories API\nconst categoriesAPI = createCRUDAPI(\"categories\");\n// File upload helper\nconst uploadFile = async (file)=>{\n    const formData = new FormData();\n    formData.append(\"files\", file);\n    const response = await api.post(\"/upload\", formData, {\n        headers: {\n            \"Content-Type\": \"multipart/form-data\"\n        }\n    });\n    return response.data;\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSXdCQTtBQUpFO0FBRTFCLG9DQUFvQztBQUNwQyxNQUFNRSxlQUFlRiwyQkFBa0MsSUFBSTtBQUMzRCxNQUFNSyxrQkFBa0JMLEVBQUFBLHNDQUFBQSwyQkFBa0MsY0FBbENBLDBEQUFBQSxvQ0FBb0NNLE9BQU8sQ0FBQyxRQUFRLFFBQU87QUFDbkYsTUFBTUMsWUFBWVAsT0FBT0EsQ0FBQ0csR0FBRyxDQUFDSyxnQkFBZ0I7QUFFOUMsd0JBQXdCO0FBQ3hCLE1BQU1DLE1BQU1SLDZDQUFLQSxDQUFDUyxNQUFNLENBQUM7SUFDdkJDLFNBQVNUO0lBQ1RVLFNBQVM7UUFDUCxnQkFBZ0I7SUFDbEI7QUFDRjtBQUVBLGdEQUFnRDtBQUNoREgsSUFBSUksWUFBWSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FDMUIsQ0FBQ0M7UUFFd0JBLGFBRWFBO0lBSHBDLG9EQUFvRDtJQUNwRCxNQUFNQyxrQkFBaUJELGNBQUFBLE9BQU9FLEdBQUcsY0FBVkYsa0NBQUFBLFlBQVlHLFFBQVEsQ0FBQztJQUU1Q0MsUUFBUUMsR0FBRyxDQUFDLGtDQUF3REwsUUFBaENBLGlCQUFBQSxPQUFPTSxNQUFNLGNBQWJOLHFDQUFBQSxlQUFlTyxXQUFXLElBQUcsS0FBb0JQLE9BQWpCQSxPQUFPTCxPQUFPLEVBQWMsT0FBWEssT0FBT0UsR0FBRyxHQUFJO1FBQ2pHRDtRQUNBTyxhQUFhLENBQUMsQ0FBQ0MsYUFBYUMsT0FBTyxDQUFDO1FBQ3BDQyxhQUFhLENBQUMsQ0FBQ3BCO1FBQ2ZLLFNBQVNJLE9BQU9KLE9BQU87UUFDdkJnQixNQUFNWixPQUFPWSxJQUFJO0lBQ25CO0lBRUEsSUFBSSxDQUFDWCxnQkFBZ0I7UUFDbkIsTUFBTVksUUFBUUosYUFBYUMsT0FBTyxDQUFDO1FBQ25DLElBQUlHLE9BQU87WUFDVGIsT0FBT0osT0FBTyxDQUFDa0IsYUFB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ZCxNQUFNaEcsV0FBVyxNQUFNekIsSUFBSWlDLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDN0MyQixRQUFRO2dCQUNOQyxVQUFVO1lBQ1o7UUFDRjtRQUNBLE9BQU9wQyxTQUFTTixJQUFJO0lBQ3RCO0lBRUEsd0JBQXdCO0lBQ3hCdUcsZ0JBQWdCO1FBQ2QsTUFBTWpHLFdBQVcsTUFBTXpCLElBQUlpQyxHQUFHLENBQUMsYUFBYTtZQUMxQzJCLFFBQVE7Z0JBQ05DLFVBQVU7WUFDWjtRQUNGO1FBQ0EsT0FBT3BDLFNBQVNOLElBQUk7SUFDdEI7QUFDRixFQUFFO0FBRUYsaUJBQWlCO0FBQ1YsTUFBTXdHLGdCQUFnQjFELGNBQWMsY0FBYztBQUV6RCxxQkFBcUI7QUFDZCxNQUFNMkQsYUFBYSxPQUFPQztJQUMvQixNQUFNQyxXQUFXLElBQUlDO0lBQ3JCRCxTQUFTeEIsTUFBTSxDQUFDLFNBQVN1QjtJQUV6QixNQUFNcEcsV0FBVyxNQUFNekIsSUFBSXFDLElBQUksQ0FBQyxXQUFXeUYsVUFBVTtRQUNuRDNILFNBQVM7WUFDUCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUVBLE9BQU9zQixTQUFTTixJQUFJO0FBQ3RCLEVBQUU7QUFFRiwrREFBZW5CLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2FwaS50cz85NTZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcblxyXG4vLyBHZXQgQVBJIGJhc2UgVVJMIGZyb20gZW52aXJvbm1lbnRcclxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1RSQVBJX1VSTCB8fCAnJztcclxuY29uc3QgU1RSQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1RSQVBJX1VSTD8ucmVwbGFjZSgnL2FwaScsICcnKSB8fCAnJztcclxuY29uc3QgQVBJX1RPS0VOID0gcHJvY2Vzcy5lbnYuU1RSQVBJX0FQSV9UT0tFTjtcclxuXHJcbi8vIENyZWF0ZSBheGlvcyBpbnN0YW5jZVxyXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IEFQSV9CQVNFX1VSTCxcclxuICBoZWFkZXJzOiB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuLy8gQWRkIHJlcXVlc3QgaW50ZXJjZXB0b3IgdG8gaW5jbHVkZSBhdXRoIHRva2VuXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgLy8gRG9uJ3QgYWRkIEF1dGhvcml6YXRpb24gaGVhZGVyIGZvciBhdXRoIGVuZHBvaW50c1xyXG4gICAgY29uc3QgaXNBdXRoRW5kcG9pbnQgPSBjb25maWcudXJsPy5pbmNsdWRlcygnL2F1dGgvJyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfjJAgTUFJTiBBUEkgUkVRVUVTVDogJHtjb25maWcubWV0aG9kPy50b1VwcGVyQ2FzZSgpfSAke2NvbmZpZy5iYXNlVVJMfSR7Y29uZmlnLnVybH1gLCB7XHJcbiAgICAgIGlzQXV0aEVuZHBvaW50LFxyXG4gICAgICBoYXNKd3RUb2tlbjogISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0X3Rva2VuJyksXHJcbiAgICAgIGhhc0FwaVRva2VuOiAhIUFQSV9UT0tFTixcclxuICAgICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgIGRhdGE6IGNvbmZpZy5kYXRhXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIWlzQXV0aEVuZHBvaW50KSB7XHJcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dF90b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflJAgQWRkZWQgSldUIHRva2VuIHRvIHJlcXVlc3RgKTtcclxuICAgICAgfSBlbHNlIGlmIChBUElfVE9LRU4pIHtcclxuICAgICAgICAvLyBVc2UgQVBJIHRva2VuIG9ubHkgaWYgbm8gSldUIHRva2VuIHByZXNlbnRcclxuICAgICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke0FQSV9UT0tFTn1gO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SRIEFkZGVkIEFQSSB0b2tlbiB0byByZXF1ZXN0YCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qrIFNraXBwaW5nIGF1dGggdG9rZW4gZm9yIGF1dGggZW5kcG9pbnRgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBSZXF1ZXN0IGludGVyY2VwdG9yIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgfVxyXG4pO1xyXG5cclxuLy8gQWRkIHJlc3BvbnNlIGludGVyY2VwdG9yIGZvciBlcnJvciBoYW5kbGluZ1xyXG5hcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcclxuICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLFxyXG4gIChlcnJvcikgPT4ge1xyXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAvLyBVbmF1dGhvcml6ZWQgLSBjbGVhciB0b2tlbiBhbmQgcmVkaXJlY3QgdG8gbG9naW5cclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2p3dF90b2tlbicpO1xyXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvYXV0aC9sb2dpbic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gIH1cclxuKTtcclxuXHJcbi8vIFRlc3QgZnVuY3Rpb24gdG8gY2hlY2sgU3RyYXBpIGVuZHBvaW50c1xyXG5leHBvcnQgY29uc3QgdGVzdFN0cmFwaUNvbm5lY3Rpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdUZXN0aW5nIFN0cmFwaSBjb25uZWN0aW9uLi4uJyk7XHJcblxyXG4gICAgLy8gVGVzdCAxOiBDaGVjayBpZiBTdHJhcGkgaXMgcnVubmluZ1xyXG4gICAgY29uc3QgcmVzcG9uc2UxID0gYXdhaXQgYXhpb3MuZ2V0KGAke1NUUkFQSV9CQVNFX1VSTH0vYCk7XHJcbiAgICBjb25zb2xlLmxvZygnU3RyYXBpIHJvb3Qgc3RhdHVzOicsIHJlc3BvbnNlMS5zdGF0dXMpO1xyXG5cclxuICAgIC8vIFRlc3QgMjogQ2hlY2sgaWYgQVBJIGVuZHBvaW50cyBleGlzdFxyXG4gICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9CQVNFX1VSTH0vdXNlcnNgKTtcclxuICAgIGNvbnNvbGUubG9nKCdBUEkgdXNlcnMgc3RhdHVzOicsIHJlc3BvbnNlMi5zdGF0dXMpO1xyXG5cclxuICAgIC8vIFRlc3QgMzogVHJ5IGF1dGggZW5kcG9pbnQgd2l0aCBkaWZmZXJlbnQgVVJMc1xyXG4gICAgY29uc3QgcG9zc2libGVBdXRoVXJscyA9IFtcclxuICAgICAgYCR7U1RSQVBJX0JBU0VfVVJMfS9hdXRoL2xvY2FsYCxcclxuICAgICAgYCR7QVBJX0JBU0VfVVJMfS9hdXRoL2xvY2FsYCxcclxuICAgICAgYCR7U1RSQVBJX0JBU0VfVVJMfS9hcGkvYXV0aC9sb2NhbGAsXHJcbiAgICBdO1xyXG5cclxuICAgIGZvciAoY29uc3QgdXJsIG9mIHBvc3NpYmxlQXV0aFVybHMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB0ZXN0UmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KHVybCwge30sIHtcclxuICAgICAgICAgIHZhbGlkYXRlU3RhdHVzOiAoKSA9PiB0cnVlIC8vIERvbid0IHRocm93IG9uIGVycm9yIHN0YXR1cyBjb2Rlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBBdXRoIGVuZHBvaW50IHRlc3QgZm9yICR7dXJsfTpgLCB0ZXN0UmVzcG9uc2Uuc3RhdHVzLCB0ZXN0UmVzcG9uc2Uuc3RhdHVzVGV4dCk7XHJcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBBdXRoIGVuZHBvaW50IHRlc3QgZm9yICR7dXJsfTogRVJST1JgLCBlLmNvZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignU3RyYXBpIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQXV0aCBlbmRwb2ludHNcclxuZXhwb3J0IGNvbnN0IGF1dGhBUEkgPSB7XHJcbiAgbG9naW46IGFzeW5jIChpZGVudGlmaWVyOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgIC8vIFRyeSBkaWZmZXJlbnQgZW5kcG9pbnQgcGF0dGVybnNcclxuICAgIGNvbnN0IGVuZHBvaW50cyA9IFtcclxuICAgICAgJy9hdXRoL2xvY2FsJywgIC8vIFN0YW5kYXJkIFN0cmFwaSBwdWJsaWMgZW5kcG9pbnRcclxuICAgICAgJy9hZG1pbi9sb2dpbicsIC8vIEFkbWluIHBhbmVsIGVuZHBvaW50XHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfwn5SNIEFQSV9CQVNFX1VSTDonLCBBUElfQkFTRV9VUkwpO1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gU1RSQVBJX0JBU0VfVVJMOicsIFNUUkFQSV9CQVNFX1VSTCk7XHJcblxyXG4gICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludHMpIHtcclxuICAgICAgLy8gVXNlIEFQSV9CQVNFX1VSTCBmb3IgYXV0aCBlbmRwb2ludHMgKGluY2x1ZGVzIC9hcGkpXHJcbiAgICAgIGNvbnN0IGxvZ2luVXJsID0gYCR7QVBJX0JBU0VfVVJMfSR7ZW5kcG9pbnR9YDtcclxuICAgICAgY29uc29sZS5sb2coYD09PSBBdHRlbXB0aW5nIGxvZ2luIHRvOiAke2xvZ2luVXJsfSA9PT1gKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVXNlIGRpcmVjdCBheGlvcyBjYWxsIHRvIGF2b2lkIGJhc2VVUkwgY29uZnVzaW9uXHJcbiAgICAgICAgY29uc3QgYXhpb3NJbnN0YW5jZSA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgICAgICAgICBiYXNlVVJMOiBBUElfQkFTRV9VUkwsIC8vIFVzZSBBUElfQkFTRV9VUkwgd2hpY2ggaW5jbHVkZXMgL2FwaVxyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVHJ5IGRpZmZlcmVudCBwYXlsb2FkIGZvcm1hdHNcclxuICAgICAgICBjb25zdCBwYXlsb2FkcyA9IFtcclxuICAgICAgICAgIHsgaWRlbnRpZmllciwgcGFzc3dvcmQgfSwgICAgLy8gU3RhbmRhcmQgZm9ybWF0XHJcbiAgICAgICAgICB7IGVtYWlsOiBpZGVudGlmaWVyLCBwYXNzd29yZCB9LCAvLyBBZG1pbiBmb3JtYXRcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcGF5bG9hZHMpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAtLS0gVHJ5aW5nIHBheWxvYWQgZm9yICR7ZW5kcG9pbnR9OmAsIHBheWxvYWQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvc0luc3RhbmNlLnBvc3QoZW5kcG9pbnQsIHBheWxvYWQpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBTVUNDRVNTISBMb2dpbiBzdWNjZXNzZnVsIHdpdGggJHtlbmRwb2ludH0gdXNpbmcgcGF5bG9hZDpgLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBSZXNwb25zZSBkYXRhOmAsIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc3BvbnNlIGhlYWRlcnM6YCwgcmVzcG9uc2UuaGVhZGVycyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVzcG9uc2Ugc3RhdHVzOmAsIHJlc3BvbnNlLnN0YXR1cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHBheWxvYWRFcnJvcjogYW55KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgUGF5bG9hZCBmYWlsZWQgZm9yICR7ZW5kcG9pbnR9OmAsIHtcclxuICAgICAgICAgICAgICBzdGF0dXM6IHBheWxvYWRFcnJvci5yZXNwb25zZT8uc3RhdHVzLFxyXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHBheWxvYWRFcnJvci5yZXNwb25zZT8uc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkRXJyb3IucmVzcG9uc2U/LmRhdGEsXHJcbiAgICAgICAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHBheWxvYWRFcnJvci5jb25maWc/Lm1ldGhvZCxcclxuICAgICAgICAgICAgICAgIHVybDogcGF5bG9hZEVycm9yLmNvbmZpZz8udXJsLFxyXG4gICAgICAgICAgICAgICAgYmFzZVVSTDogcGF5bG9hZEVycm9yLmNvbmZpZz8uYmFzZVVSTCxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHBheWxvYWRFcnJvci5jb25maWc/LmhlYWRlcnNcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gNDAwIG1lYW5zIGVuZHBvaW50IGV4aXN0cyBidXQgY3JlZGVudGlhbHMgYXJlIHdyb25nIC0gdGhpcyBpcyBleHBlY3RlZCBiZWhhdmlvclxyXG4gICAgICAgICAgICBpZiAocGF5bG9hZEVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gSU5GTzogNDAwIEJhZCBSZXF1ZXN0IGZvciAke2VuZHBvaW50fSAtIGVuZHBvaW50IGV4aXN0cyBidXQgY3JlZGVudGlhbHMgYXJlIGludmFsaWRgKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgZW5kcG9pbnQgdGhhdCByZXR1cm5zIDQwMCwgdGhyb3cgaXQgc28gdXNlciBzZWVzIFwiSW52YWxpZCBjcmVkZW50aWFsc1wiXHJcbiAgICAgICAgICAgICAgdGhyb3cgcGF5bG9hZEVycm9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgb3RoZXIgZXJyb3JzICg0MDQsIDQwNSwgZXRjLiksIGNvbnRpbnVlIHRvIG5leHQgcGF5bG9hZFxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVuZHBvaW50RXJyb3I6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGA9PT0gRW5kcG9pbnQgJHtlbmRwb2ludH0gY29tcGxldGVseSBmYWlsZWQgPT09YCwge1xyXG4gICAgICAgICAgc3RhdHVzOiBlbmRwb2ludEVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiBlbmRwb2ludEVycm9yLnJlc3BvbnNlPy5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgZGF0YTogZW5kcG9pbnRFcnJvci5yZXNwb25zZT8uZGF0YSxcclxuICAgICAgICAgIG1lc3NhZ2U6IGVuZHBvaW50RXJyb3IubWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGlzIGVuZHBvaW50IGRvZXNuJ3QgZXhpc3QgKDQwNCkgb3IgbWV0aG9kIG5vdCBhbGxvd2VkICg0MDUpLCB0cnkgbmV4dCBlbmRwb2ludFxyXG4gICAgICAgIGlmIChlbmRwb2ludEVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwNCB8fCBlbmRwb2ludEVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwNSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBJTkZPOiBFbmRwb2ludCAke2VuZHBvaW50fSBub3QgYXZhaWxhYmxlICgke2VuZHBvaW50RXJyb3IucmVzcG9uc2U/LnN0YXR1c30pLCB0cnlpbmcgbmV4dCBlbmRwb2ludGApO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSA0MDAgKGludmFsaWQgY3JlZGVudGlhbHMpLCB0aGF0IG1lYW5zIHRoZSBlbmRwb2ludCBleGlzdHMgYnV0IGNyZWRlbnRpYWxzIGFyZSB3cm9uZ1xyXG4gICAgICAgIGlmIChlbmRwb2ludEVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBJTkZPOiBFbmRwb2ludCAke2VuZHBvaW50fSBleGlzdHMgYnV0IGNyZWRlbnRpYWxzIGludmFsaWQgLSB0aHJvd2luZyBlcnJvcmApO1xyXG4gICAgICAgICAgdGhyb3cgZW5kcG9pbnRFcnJvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciBvdGhlciBlcnJvcnMsIGNvbnRpbnVlIHRvIG5leHQgZW5kcG9pbnRcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIGdldCBoZXJlLCBhbGwgZW5kcG9pbnRzIGZhaWxlZCB3aXRoIG5vbi00MDAgZXJyb3JzXHJcbiAgICBjb25zb2xlLmVycm9yKGDwn5qoIEVSUk9SOiBBbGwgYXV0aGVudGljYXRpb24gZW5kcG9pbnRzIGZhaWxlZGApO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBhdXRoZW50aWNhdGlvbiBlbmRwb2ludCBmb3VuZCcpO1xyXG4gIH0sXHJcblxyXG4gIHJlZ2lzdGVyOiBhc3luYyAodXNlcm5hbWU6IHN0cmluZywgZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvbG9jYWwvcmVnaXN0ZXInLCB7XHJcbiAgICAgIHVzZXJuYW1lLFxyXG4gICAgICBlbWFpbCxcclxuICAgICAgcGFzc3dvcmQsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0sXHJcblxyXG4gIG1lOiBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy91c2Vycy9tZScsIHtcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgcG9wdWxhdGU6ICcqJ1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0sXHJcblxyXG4gIGZvcmdvdFBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvZm9yZ290LXBhc3N3b3JkJywge1xyXG4gICAgICBlbWFpbCxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSxcclxuXHJcbiAgcmVzZXRQYXNzd29yZDogYXN5bmMgKGNvZGU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgcGFzc3dvcmRDb25maXJtYXRpb246IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvcmVzZXQtcGFzc3dvcmQnLCB7XHJcbiAgICAgIGNvZGUsXHJcbiAgICAgIHBhc3N3b3JkLFxyXG4gICAgICBwYXNzd29yZENvbmZpcm1hdGlvbixcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEdlbmVyaWMgQ1JVRCBvcGVyYXRpb25zXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDUlVEQVBJID0gKGVuZHBvaW50OiBzdHJpbmcpID0+ICh7XHJcbiAgZ2V0QWxsOiBhc3luYyAocGFyYW1zID0ge30pID0+IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIFtDUlVEXSAke2VuZHBvaW50fS5nZXRBbGwgY2FsbGVkIHdpdGggcGFyYW1zOmAsIHBhcmFtcyk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC8ke2VuZHBvaW50fWAsIHsgcGFyYW1zIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFtDUlVEXSAke2VuZHBvaW50fS5nZXRBbGwgU1VDQ0VTUzpgLCB7XHJcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgZGF0YUNvdW50OiByZXNwb25zZS5kYXRhPy5kYXRhPy5sZW5ndGggfHwgMCxcclxuICAgICAgICBoYXNEYXRhOiAhIXJlc3BvbnNlLmRhdGE/LmRhdGEsXHJcbiAgICAgICAgZGF0YUtleXM6IHJlc3BvbnNlLmRhdGEgPyBPYmplY3Qua2V5cyhyZXNwb25zZS5kYXRhKSA6ICdudWxsJ1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7IC8vIFJldHVybnMgeyBkYXRhOiBbLi4uXSwgbWV0YTogey4uLn0gfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgW0NSVURdICR7ZW5kcG9pbnR9LmdldEFsbCBFUlJPUjpgLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogZXJyb3IucmVzcG9uc2U/LnN0YXR1c1RleHQsXHJcbiAgICAgICAgZGF0YTogZXJyb3IucmVzcG9uc2U/LmRhdGFcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldEJ5SWQ6IGFzeW5jIChpZDogc3RyaW5nIHwgbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBbQ1JVRF0gJHtlbmRwb2ludH0uZ2V0QnlJZCBjYWxsZWQgd2l0aCBpZDpgLCBpZCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC8ke2VuZHBvaW50fS8ke2lkfWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFtDUlVEXSAke2VuZHBvaW50fS5nZXRCeUlkIFNVQ0NFU1M6YCwge1xyXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIGhhc0RhdGE6ICEhcmVzcG9uc2UuZGF0YT8uZGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7IC8vIFJldHVybnMgeyBkYXRhOiB7Li4ufSB9XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBbQ1JVRF0gJHtlbmRwb2ludH0uZ2V0QnlJZCBFUlJPUjpgLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogZXJyb3IucmVzcG9uc2U/LnN0YXR1c1RleHRcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZTogYXN5bmMgKGRhdGE6IGFueSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coYPCflI0gW0NSVURdICR7ZW5kcG9pbnR9LmNyZWF0ZSBjYWxsZWQgd2l0aCBkYXRhOmAsIGRhdGEpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdChgLyR7ZW5kcG9pbnR9YCwgeyBkYXRhIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFtDUlVEXSAke2VuZHBvaW50fS5jcmVhdGUgU1VDQ0VTUzpgLCB7XHJcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgaGFzRGF0YTogISFyZXNwb25zZS5kYXRhPy5kYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIFtDUlVEXSAke2VuZHBvaW50fS5jcmVhdGUgRVJST1I6YCwge1xyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZT8uc3RhdHVzLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXNUZXh0LFxyXG4gICAgICAgIGRhdGE6IGVycm9yLnJlc3BvbnNlPy5kYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGFzeW5jIChpZDogc3RyaW5nIHwgbnVtYmVyLCBkYXRhOiBhbnkpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIFtDUlVEXSAke2VuZHBvaW50fS51cGRhdGUgY2FsbGVkIHdpdGggaWQ6YCwgaWQsICdkYXRhOicsIGRhdGEpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvJHtlbmRwb2ludH0vJHtpZH1gLCB7IGRhdGEgfSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgW0NSVURdICR7ZW5kcG9pbnR9LnVwZGF0ZSBTVUNDRVNTOmAsIHtcclxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBoYXNEYXRhOiAhIXJlc3BvbnNlLmRhdGE/LmRhdGFcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgW0NSVURdICR7ZW5kcG9pbnR9LnVwZGF0ZSBFUlJPUjpgLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogZXJyb3IucmVzcG9uc2U/LnN0YXR1c1RleHQsXHJcbiAgICAgICAgZGF0YTogZXJyb3IucmVzcG9uc2U/LmRhdGFcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGRlbGV0ZTogYXN5bmMgKGlkOiBzdHJpbmcgfCBudW1iZXIpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIFtDUlVEXSAke2VuZHBvaW50fS5kZWxldGUgY2FsbGVkIHdpdGggaWQ6YCwgaWQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZGVsZXRlKGAvJHtlbmRwb2ludH0vJHtpZH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBbQ1JVRF0gJHtlbmRwb2ludH0uZGVsZXRlIFNVQ0NFU1M6YCwge1xyXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIGhhc0RhdGE6ICEhcmVzcG9uc2UuZGF0YT8uZGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7IC8vIFJldHVybnMgeyBkYXRhOiB7Li4ufSwgbWV0YTogey4uLn0gfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgW0NSVURdICR7ZW5kcG9pbnR9LmRlbGV0ZSBFUlJPUjpgLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogZXJyb3IucmVzcG9uc2U/LnN0YXR1c1RleHRcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIEN1c3RvbSBxdWVyeSBmb3IgU3RyYXBpIGZpbHRlcnNcclxuICBmaW5kOiBhc3luYyAoZmlsdGVycyA9IHt9KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBbQ1JVRF0gJHtlbmRwb2ludH0uZmluZCBjYWxsZWQgd2l0aCBmaWx0ZXJzOmAsIGZpbHRlcnMpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvJHtlbmRwb2ludH1gLCB7XHJcbiAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICBwb3B1bGF0ZTogJyonLFxyXG4gICAgICAgICAgLi4uZmlsdGVycyxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBbQ1JVRF0gJHtlbmRwb2ludH0uZmluZCBTVUNDRVNTOmAsIHtcclxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBkYXRhQ291bnQ6IHJlc3BvbnNlLmRhdGE/LmRhdGE/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICAgIGhhc0RhdGE6ICEhcmVzcG9uc2UuZGF0YT8uZGF0YSxcclxuICAgICAgICBkYXRhS2V5czogcmVzcG9uc2UuZGF0YSA/IE9iamVjdC5rZXlzKHJlc3BvbnNlLmRhdGEpIDogJ251bGwnXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBbQ1JVRF0gJHtlbmRwb2ludH0uZmluZCBkYXRhIHNhbXBsZTpgLCByZXNwb25zZS5kYXRhPy5kYXRhPy5zbGljZSgwLCAxKSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhOyAvLyBSZXR1cm5zIHsgZGF0YTogWy4uLl0sIG1ldGE6IHsuLi59IH1cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIFtDUlVEXSAke2VuZHBvaW50fS5maW5kIEVSUk9SOmAsIHtcclxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2U/LnN0YXR1cyxcclxuICAgICAgICBzdGF0dXNUZXh0OiBlcnJvci5yZXNwb25zZT8uc3RhdHVzVGV4dCxcclxuICAgICAgICBkYXRhOiBlcnJvci5yZXNwb25zZT8uZGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxufSk7XHJcblxyXG4vLyBTcGVjaWZpYyBBUEkgZW5kcG9pbnRzXHJcbmV4cG9ydCBjb25zdCBzcGtBUEkgPSBjcmVhdGVDUlVEQVBJKCdzcGtzJyk7XHJcbmV4cG9ydCBjb25zdCB2ZWhpY2xlVHlwZXNBUEkgPSBjcmVhdGVDUlVEQVBJKCd2ZWhpY2xlLXR5cGVzJyk7XHJcbmV4cG9ydCBjb25zdCB2ZWhpY2xlR3JvdXBzQVBJID0gY3JlYXRlQ1JVREFQSSgndmVoaWNsZS1ncm91cHMnKTtcclxuZXhwb3J0IGNvbnN0IGNvbG9yc0FQSSA9IGNyZWF0ZUNSVURBUEkoJ2NvbG9ycycpO1xyXG5leHBvcnQgY29uc3Qgc3VwZXJ2aXNvcnNBUEkgPSBjcmVhdGVDUlVEQVBJKCdzdXBlcnZpc29ycycpO1xyXG5leHBvcnQgY29uc3QgYnJhbmNoZXNBUEkgPSBjcmVhdGVDUlVEQVBJKCdicmFuY2hlcycpO1xyXG5leHBvcnQgY29uc3Qgc2FsZXNTdGFmZkFQSSA9IGNyZWF0ZUNSVURBUEkoJ3NhbGVzLXN0YWZmcycpO1xyXG5cclxuLy8gU2FsZXMgUHJvZmlsZSBBUElcclxuZXhwb3J0IGNvbnN0IHNhbGVzUHJvZmlsZXNBUEkgPSBjcmVhdGVDUlVEQVBJKCdzYWxlcy1wcm9maWxlcycpO1xyXG5cclxuLy8gSW5mb3JtYXRpb24vQXJ0aWNsZXMgQVBJXHJcbmV4cG9ydCBjb25zdCBhcnRpY2xlc0FQSSA9IGNyZWF0ZUNSVURBUEkoJ2FydGljbGVzJyk7XHJcblxyXG4vLyBTYWxlcyBNb25pdG9yaW5nIEFQSVxyXG5leHBvcnQgY29uc3Qgc2FsZXNNb25pdG9yaW5nQVBJID0ge1xyXG4gIC8vIEdldCBhbGwgc2FsZXMgcHJvZmlsZXMgd2l0aCB0aGVpciBTUEsgZGF0YSBhbmQgcG9wdWxhdGVkIHJlbGF0aW9uc2hpcHNcclxuICBnZXRTYWxlc1Byb2ZpbGVzV2l0aFNQSzogYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gVXNlIFVSTC1lbmNvZGVkIHBvcHVsYXRlIHBhcmFtZXRlcnMgZm9yIFN0cmFwaVxyXG4gICAgY29uc3QgcG9wdWxhdGVQYXJhbXMgPSBbXHJcbiAgICAgICdwb3B1bGF0ZVtwaG90b19wcm9maWxlXScsXHJcbiAgICAgICdwb3B1bGF0ZVtzcGtzXVtwb3B1bGF0ZV1bdW5pdEluZm9dW3BvcHVsYXRlXVt2ZWhpY2xlVHlwZV0nLFxyXG4gICAgICAncG9wdWxhdGVbc3Brc11bcG9wdWxhdGVdW3VuaXRJbmZvXVtwb3B1bGF0ZV1bY29sb3JdJyxcclxuICAgICAgJ3BvcHVsYXRlW3Nwa3NdW3BvcHVsYXRlXVtkZXRhaWxJbmZvXScsXHJcbiAgICAgICdwb3B1bGF0ZVtzcGtzXVtwb3B1bGF0ZV1bcGF5bWVudEluZm9dJ1xyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgIHBvcHVsYXRlOiBwb3B1bGF0ZVBhcmFtcy5qb2luKCcmJyksXHJcbiAgICAgIGZpbHRlcnM6IHtcclxuICAgICAgICBibG9ja2VkOiBmYWxzZVxyXG4gICAgICB9LFxyXG4gICAgICBzb3J0OiAndXBkYXRlZEF0OmRlc2MnXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfwn5SNIFtTYWxlc01vbml0b3JpbmddIEFQSSBSZXF1ZXN0IHBhcmFtczonLCBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDIpKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBCdWlsZCB0aGUgVVJMIG1hbnVhbGx5IGZvciBjb21wbGV4IHBvcHVsYXRlXHJcbiAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgICBwb3B1bGF0ZVBhcmFtcy5mb3JFYWNoKHBhcmFtID0+IHF1ZXJ5U3RyaW5nLmFwcGVuZChwYXJhbSwgJycpKTtcclxuICAgICAgcXVlcnlTdHJpbmcuYXBwZW5kKCdmaWx0ZXJzW2Jsb2NrZWRdJywgJ2ZhbHNlJyk7XHJcbiAgICAgIHF1ZXJ5U3RyaW5nLmFwcGVuZCgnc29ydCcsICd1cGRhdGVkQXQ6ZGVzYycpO1xyXG5cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvc2FsZXMtcHJvZmlsZXM/JHtxdWVyeVN0cmluZy50b1N0cmluZygpfWApO1xyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFtTYWxlc01vbml0b3JpbmddIEFQSSBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogW1NhbGVzTW9uaXRvcmluZ10gUmVzcG9uc2UgZGF0YSBjb3VudDonLCByZXNwb25zZS5kYXRhPy5kYXRhPy5sZW5ndGggfHwgMCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgW1NhbGVzTW9uaXRvcmluZ10gQVBJIEVycm9yOicsIGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsIGVycm9yLnJlc3BvbnNlPy5kYXRhKTtcclxuICAgICAgLy8gVHJ5IHNpbXBsZXIgcG9wdWxhdGUgaWYgY29tcGxleCBvbmUgZmFpbHNcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBbU2FsZXNNb25pdG9yaW5nXSBUcnlpbmcgc2ltcGxlciBwb3B1bGF0ZS4uLicpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3NhbGVzLXByb2ZpbGVzP3BvcHVsYXRlPSonKTtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFtTYWxlc01vbml0b3JpbmddIFNpbXBsZSBwb3B1bGF0ZSBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBbU2FsZXNNb25pdG9yaW5nXSBSZXNwb25zZSBkYXRhIGNvdW50OicsIHJlc3BvbnNlLmRhdGE/LmRhdGE/Lmxlbmd0aCB8fCAwKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcjogYW55KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFtTYWxlc01vbml0b3JpbmddIEZhbGxiYWNrIEFQSSBFcnJvcjonLCBmYWxsYmFja0Vycm9yLnJlc3BvbnNlPy5zdGF0dXMsIGZhbGxiYWNrRXJyb3IucmVzcG9uc2U/LmRhdGEpO1xyXG4gICAgICAgIHRocm93IGZhbGxiYWNrRXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBHZXQgc2FsZXMgcHJvZmlsZXMgZmlsdGVyZWQgYnkgb25saW5lIHN0YXR1c1xyXG4gIGdldFNhbGVzUHJvZmlsZXNCeVN0YXR1czogYXN5bmMgKG9ubGluZVN0YXR1cz86IGJvb2xlYW4pID0+IHtcclxuICAgIGNvbnN0IGZpbHRlcnM6IGFueSA9IHtcclxuICAgICAgYXBwcm92ZWQ6IHRydWUsXHJcbiAgICAgIGJsb2NrZWQ6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvbmxpbmVTdGF0dXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBmaWx0ZXJzLm9ubGluZV9zdGF0ID0gb25saW5lU3RhdHVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3NhbGVzLXByb2ZpbGVzJywge1xyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBwb3B1bGF0ZTogJyonLFxyXG4gICAgICAgIGZpbHRlcnMsXHJcbiAgICAgICAgc29ydDoge1xyXG4gICAgICAgICAgdXBkYXRlZEF0OiAnZGVzYydcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSxcclxuXHJcbiAgLy8gVXBkYXRlIHNhbGVzIHByb2ZpbGUgbG9jYXRpb24gYW5kIG9ubGluZSBzdGF0dXNcclxuICB1cGRhdGVTYWxlc1Byb2ZpbGVMb2NhdGlvbjogYXN5bmMgKHByb2ZpbGVJZDogbnVtYmVyLCBsb2NhdGlvbjogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlciB9LCBvbmxpbmVTdGF0dXM6IGJvb2xlYW4pID0+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL3NhbGVzLXByb2ZpbGVzLyR7cHJvZmlsZUlkfWAsIHtcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGxvY2F0aW9uLFxyXG4gICAgICAgIG9ubGluZV9zdGF0OiBvbmxpbmVTdGF0dXMsXHJcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBVc2VyIG1hbmFnZW1lbnQgQVBJXHJcbmV4cG9ydCBjb25zdCB1c2Vyc0FQSSA9IHtcclxuICAvLyBHZXQgYWxsIHVzZXJzIHdpdGggU0FMRVMgcm9sZVxyXG4gIGdldFNhbGVzVXNlcnM6IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3VzZXJzJywge1xyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBmaWx0ZXJzOiB7XHJcbiAgICAgICAgICByb2xlX2N1c3RvbTogJ1NBTEVTJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG9wdWxhdGU6ICcqJ1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0sXHJcblxyXG4gIC8vIFVwZGF0ZSB1c2VyIGRhdGFcclxuICB1cGRhdGVVc2VyOiBhc3luYyAodXNlcklkOiBudW1iZXIsIHVzZXJEYXRhOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL3VzZXJzLyR7dXNlcklkfWAsIHsgZGF0YTogdXNlckRhdGEgfSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9LFxyXG5cclxuICAvLyBHZXQgc3VwZXJ2aXNvcnMgZm9yIGRyb3Bkb3duXHJcbiAgZ2V0U3VwZXJ2aXNvcnM6IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3N1cGVydmlzb3JzJywge1xyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBwb3B1bGF0ZTogJyonXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSxcclxuXHJcbiAgLy8gR2V0IGN1cnJlbnQgdXNlciBpbmZvXHJcbiAgZ2V0Q3VycmVudFVzZXI6IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3VzZXJzL21lJywge1xyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBwb3B1bGF0ZTogJyonXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQ2F0ZWdvcmllcyBBUElcclxuZXhwb3J0IGNvbnN0IGNhdGVnb3JpZXNBUEkgPSBjcmVhdGVDUlVEQVBJKCdjYXRlZ29yaWVzJyk7XHJcblxyXG4vLyBGaWxlIHVwbG9hZCBoZWxwZXJcclxuZXhwb3J0IGNvbnN0IHVwbG9hZEZpbGUgPSBhc3luYyAoZmlsZTogRmlsZSkgPT4ge1xyXG4gIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgZm9ybURhdGEuYXBwZW5kKCdmaWxlcycsIGZpbGUpO1xyXG5cclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvdXBsb2FkJywgZm9ybURhdGEsIHtcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXBpOyJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJlbnYiLCJORVhUX1BVQkxJQ19TVFJBUElfVVJMIiwiU1RSQVBJX0JBU0VfVVJMIiwicmVwbGFjZSIsIkFQSV9UT0tFTiIsIlNUUkFQSV9BUElfVE9LRU4iLCJhcGkiLCJjcmVhdGUiLCJiYXNlVVJMIiwiaGVhZGVycyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJpc0F1dGhFbmRwb2ludCIsInVybCIsImluY2x1ZGVzIiwiY29uc29sZSIsImxvZyIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwiaGFzSnd0VG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaGFzQXBpVG9rZW4iLCJkYXRhIiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJyZW1vdmVJdGVtIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwidGVzdFN0cmFwaUNvbm5lY3Rpb24iLCJyZXNwb25zZTEiLCJnZXQiLCJyZXNwb25zZTIiLCJwb3NzaWJsZUF1dGhVcmxzIiwidGVzdFJlc3BvbnNlIiwicG9zdCIsInZhbGlkYXRlU3RhdHVzIiwic3RhdHVzVGV4dCIsImUiLCJjb2RlIiwibWVzc2FnZSIsImF1dGhBUEkiLCJsb2dpbiIsImlkZW50aWZpZXIiLCJwYXNzd29yZCIsImVuZHBvaW50cyIsImVuZHBvaW50IiwibG9naW5VcmwiLCJheGlvc0luc3RhbmNlIiwicGF5bG9hZHMiLCJlbWFpbCIsInBheWxvYWQiLCJwYXlsb2FkRXJyb3IiLCJlbmRwb2ludEVycm9yIiwiRXJyb3IiLCJyZWdpc3RlciIsInVzZXJuYW1lIiwibWUiLCJwYXJhbXMiLCJwb3B1bGF0ZSIsImZvcmdvdFBhc3N3b3JkIiwicmVzZXRQYXNzd29yZCIsInBhc3N3b3JkQ29uZmlybWF0aW9uIiwiY3JlYXRlQ1JVREFQSSIsImdldEFsbCIsImRhdGFDb3VudCIsImxlbmd0aCIsImhhc0RhdGEiLCJkYXRhS2V5cyIsIk9iamVjdCIsImtleXMiLCJnZXRCeUlkIiwiaWQiLCJ1cGRhdGUiLCJwdXQiLCJkZWxldGUiLCJmaW5kIiwiZmlsdGVycyIsInNsaWNlIiwic3BrQVBJIiwidmVoaWNsZVR5cGVzQVBJIiwidmVoaWNsZUdyb3Vwc0FQSSIsImNvbG9yc0FQSSIsInN1cGVydmlzb3JzQVBJIiwiYnJhbmNoZXNBUEkiLCJzYWxlc1N0YWZmQVBJIiwic2FsZXNQcm9maWxlc0FQSSIsImFydGljbGVzQVBJIiwic2FsZXNNb25pdG9yaW5nQVBJIiwiZ2V0U2FsZXNQcm9maWxlc1dpdGhTUEsiLCJwb3B1bGF0ZVBhcmFtcyIsImpvaW4iLCJibG9ja2VkIiwic29ydCIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeVN0cmluZyIsIlVSTFNlYXJjaFBhcmFtcyIsImZvckVhY2giLCJwYXJhbSIsImFwcGVuZCIsInRvU3RyaW5nIiwiZmFsbGJhY2tFcnJvciIsImdldFNhbGVzUHJvZmlsZXNCeVN0YXR1cyIsIm9ubGluZVN0YXR1cyIsImFwcHJvdmVkIiwidW5kZWZpbmVkIiwib25saW5lX3N0YXQiLCJ1cGRhdGVkQXQiLCJ1cGRhdGVTYWxlc1Byb2ZpbGVMb2NhdGlvbiIsInByb2ZpbGVJZCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVzZXJzQVBJIiwiZ2V0U2FsZXNVc2VycyIsInJvbGVfY3VzdG9tIiwidXBkYXRlVXNlciIsInVzZXJJZCIsInVzZXJEYXRhIiwiZ2V0U3VwZXJ2aXNvcnMiLCJnZXRDdXJyZW50VXNlciIsImNhdGVnb3JpZXNBUEkiLCJ1cGxvYWRGaWxlIiwiZmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api.ts\n"));

/***/ })

});